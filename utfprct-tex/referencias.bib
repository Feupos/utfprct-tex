@phdthesis{doc_simao_2005,
author = {Sim{\~a}o, Jean},
year = {2005},
month = {06},
title = {A Contribution to the Development of a HMS Simulation Tool and Proposition of a Meta-Model for Holonic Control},
school = {UTFPR , Henri Poincaré University}
}

@phdthesis{doc_linhares_2015,
author = {Linhares, Robson Ribeiro},
title = {Contribuiç{\~a}o para o desenvolvimento de uma arquitetura de computaç{\~a}o própria ao paradigma orientado a notificações},
year = {2015},
school = {UTFPR}
}

@phdthesis{doc_Kerschbaumer_2018,
author = {Kerschbaumer, R},
title = {Proposiç{\~a}o do paradigma orientado a notificações no desenvolvimento de circuitos lógico-digitais reconfiguráveis},
year = {2018},
school = {UTFPR}
}

@phdthesis{doc_ronszcka_2019,
author = {Ronszcka, A. F.},
year = {2019},
title = {Método para a Criaç{\~a}o de Linguagens de Programaç{\~a}o e Compiladores para o Paradigma Orientado a Notificações em Plataformas Distintas},
school = {UTFPR},
address     = {CPGEI}
}

@phdthesis{doc_Schutz_2019,
author = {Sch{\"u}tz, F.},
year = {2019},
title = {NEURO-PON: Uma Abordagem para o Desenvolvimento de Redes Neurais Artificiais Utilizando o Paradigma Orientado a Notificações},
school = {UTFPR}
}

@mastersthesis{msc_simao_2001,
author = {Sim{\~a}o, J. M.},
year = {2001},
school = {UTFPR},
address = {CPGEI},
title = {Proposta de uma Arquitetura de Controle para Sistemas Flexíveis de Manufatura Baseada em Regras e Agentes}
}

@mastersthesis{msc_Banaszewski_2009,
author = {Banaszewski, R. F.},
year = {2009},
school = {UTFPR},
title = {Paradigma Orientado a Notificações: Avanços e Comparações}
}

@mastersthesis{msc_Wiecheteck_2011,
author = {Wiecheteck, L. V. B.},
year = {2011},
school = {UTFPR},
title = {Método para projeto de software usando o paradigma orientado a notificações – PON}
}

@mastersthesis{msc_Ronszcka_2012,
author = {Ronszcka, A. F.},
year = {2012},
school = {UTFPR},
address = {CPGEI},
title = {Contribuiç{\~a}o para a concepç{\~a}o de aplicações no paradigma orientado a notificações (PON) sob o viés de padrões}
}

@mastersthesis{msc_valenca_2012,
author = {Valen{\c{c}}a, G. Z.},
year = {2012},
school = {UTFPR},
title = {Contribuiç{\~a}o para materializaç{\~a}o do paradigma orientado a notificações (PON) via framework e wizard}
}


@mastersthesis{msc_Peters_2012,
author = {Peters, E.},
year = {2012},
school = {UTFPR},
title = {Coprocessador para aceleraç{\~a}o de aplicações desenvolvidas utilizando paradigma orientado a notificações}
}

@mastersthesis{msc_batista_2013,
author = {Batista, M. V.},
year = {2013},
school = {UTFPR},
title = {Proposta de um método de aplicaç{\~a}o da teoria de projeto axiomático ao desenvolvimento de software PON-POR}
}

@mastersthesis{msc_xavier_2014,
author = {Xavier, R. D.},
year = {2014},
school = {UTFPR},
address = {PPGCA},
title = {Paradigmas de desenvolvimento de software: comparaç{\~a}o entre abordagens orientada a eventos e orientada a notificações}
}

@mastersthesis{msc_Kossoski_2015,
author = {Kossoski, C.},
year = {2015},
school = {UTFPR},
title = {Proposta de um método de teste para processos de desenvolvimento de software usando o Paradigma Orientado a Notificações}
}

@mastersthesis{msc_Ferreira_2015,
author = {Ferreira, C. A.},
year = {2015},
school = {UTFPR},
title = {Linguagem e Compilador para o Paradigma Orientado a Notificações (PON): Avanços e Comparações}
}

@mastersthesis{msc_melo_2016,
author = {Melo, C. A.},
year = {2016},
school = {UTFPR},
title = {Adaptaç{\~a}o do Paradigma Orientado a Notificações para Desenvolvimento de Sistemas Fuzzy}
}

@mastersthesis{msc_santos_2017,
author = {Santos, L. A.},
year = {2017},
school = {UTFPR},
address = {CPGEI},
title = {Linguagem e Compilador para o Paradigma Orientado A Notificações: Avanços para Facilitar a Codificaç{\~a}o e sua Validaç{\~a}o em uma Aplicaç{\~a}o de Controle de Futebol de Robôs}
}

@mastersthesis{msc_novaes_2019,
author = {Dantas Novaes. P. J.},
year = {2019},
school = {UTFPR},
title = {Método e Linguagem para Modelagem Gráfica de Requisitos em \textit{Software} e Sistemas}
}

@mastersthesis{msc_negrini_2019,
author = {Negrini, F.},
year = {2019},
school = {UTFPR},
address = {CPGEI},
title = {Tecnologia NOPL Erlang-Elixir – paradigma orientado a notificações via uma abordagem orientada a microatores assíncronos}
}

@mastersthesis{msc_oliveira_2019,
author = {Oliveira, R. N.},
year = {2019},
school = {UTFPR},
title = {Paradigma Orientado a Notificações Aplicado em Assistência à Autonomia Domiciliar},
address = {CPGEI}
}


@mastersthesis{msc_pordeus_2017,
author = {Pordeus, L. F.},
year = {2017},
school = {UTFPR},
title = {Simulaç{\~a}o de uma arquitetura de computaç{\~a}o própria ao paradigma orientado a notificações},
address = {CPGEI}
}


@mastersthesis{quali_pordeus_2020,
author = {Pordeus, L. F.},
year = {2020},
school = {UTFPR},
title = {ArqTotalPON - Contribui{\c{c}}{\~a}o para Arquitetura de Computa{\c{c}}{\~a}o própria e efetiva ao Paradigma Orientado a Notifica{\c{c}}{\~o}es},
address = {CPGEI},
publisher={Trabalho de Qualificação de Doutorado, CPGEI,
UTFPR},
}

@inproceedings{microsoft_test_2009,
author={Williams, Laurie and others},
booktitle={2009 20th International Symposium on Software Reliability Engineering},
title={On the Effectiveness of Unit Test Automation at Microsoft},
year={2009},
volume={},
number={},
pages={81-89},
doi={10.1109/ISSRE.2009.32}
}

@article{bjarne_2020,
author = {Stroustrup, Bjarne},
title = {Thriving in a Crowded and Changing World: C++ 2006–2020},
year = {2020},
issue_date = {June 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {HOPL},
url = {https://doi.org/10.1145/3386320},
doi = {10.1145/3386320},
abstract = {By 2006, C++ had been in widespread industrial use for 20 years. It contained parts that had survived unchanged since introduced into C in the early 1970s as well as features that were novel in the early 2000s. From 2006 to 2020, the C++ developer community grew from about 3 million to about 4.5 million. It was a period where new programming models emerged, hardware architectures evolved, new application domains gained massive importance, and quite a few well-financed and professionally marketed languages fought for dominance. How did C++ -- an older language without serious commercial backing -- manage to thrive in the face of all that?  This paper focuses on the major changes to the ISO C++ standard for the 2011, 2014, 2017, and 2020 revisions. The standard library is about 3/4 of the C++20 standard, but this paper's primary focus is on language features and the programming techniques they support.  The paper contains long lists of features documenting the growth of C++. Significant technical points are discussed and illustrated with short code fragments. In addition, it presents some failed proposals and the discussions that led to their failure. It offers a perspective on the bewildering flow of facts and features across the years. The emphasis is on the ideas, people, and processes that shaped the language.  Themes include efforts to preserve the essence of C++ through evolutionary changes, to simplify its use, to improve support for generic programming, to better support compile-time programming, to extend support for concurrency and parallel programming, and to maintain stable support for decades' old code.  The ISO C++ standard evolves through a consensus process. Inevitably, there is competition among proposals and clashes (usually polite ones) over direction, design philosophies, and principles. The committee is now larger and more active than ever, with as many as 250 people turning up to week-long meetings three times a year and many more taking part electronically. We try (not always successfully) to mitigate the effects of design by committee, bureaucratic paralysis, and excessive enthusiasm for a variety of language fashions.  Specific language-technical topics include the memory model, concurrency and parallelism, compile-time computation, move-semantics, exceptions, lambda expressions, and modules. Designing a mechanism for specifying a template's requirements on its arguments that is sufficiently flexible and precise yet doesn't impose run-time costs turned out to be hard. The repeated attempts to design ``concepts'' to do that have their roots back in the 1980s and touch upon many key design issues for C++ and for generic programming.  The description is based on personal participation in the key events and design decisions, backed by the thousands of papers and hundreds of meeting minutes in the ISO C++ standards committee's archives.},
journal = {Proc. ACM Program. Lang.},
month = jun,
articleno = {70},
numpages = {168},
keywords = {concurrency and parallelism, generic programming, simplification of language use, C++, standardization, resource management, programming language design and evolution}
}

@inproceedings{bjarne_1995,
author = {Stroustrup, Bjarne},
title = {Why C++ is Not Just an Object-Oriented Programming Language},
year = {1995},
isbn = {0897917219},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/260094.260207},
doi = {10.1145/260094.260207},
booktitle = {Addendum to the Proceedings of the 10th Annual Conference on Object-Oriented Programming Systems, Languages, and Applications (Addendum)},
pages = {1–13},
numpages = {13},
location = {Austin, Texas, USA},
series = {OOPSLA '95}
}

@book{alexandrescu_2001,
author = {Alexandrescu, Andrei},
title = {Modern C++ Design: Generic Programming and Design Patterns Applied},
year = {2001},
isbn = {0201704315},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA},
abstract = {Modern C++ Designis an important book. Fundamentally, it demonstrates 'generic patterns' or 'pattern templates' as a powerful new way of creating extensible designs in C++\"{\i} a new way to combine templates and patterns that you may never have dreamt was possible, but is. If your work involves C++ design and coding, you should read this book. Highly recommended. \"{\i} Herb SutterWhat's left to say about C++ that hasn't already been said__ __ Plenty, it turns out. \"{\i} From the Foreword by John VlissidesIn Modern C++ Design, Andrei Alexandrescu opens new vistas for C++ programmers. Displaying extraordinary creativity and programming virtuosity, Alexandrescu offers a cutting-edge approach to design that unites design patterns, generic programming, and C++, enabling programmers to achieve expressive, flexible, and highly reusable code.This book introduces the concept of generic components\"{\i} reusable design templates that produce boilerplate code for compiler consumption\"{\i} all within C++. Generic components enable an easier and more seamless transition from design to application code, generate code that better expresses the original design intention, and support the reuse of design structures with minimal recoding.The author describes the specific C++ techniques and features that are used in building generic components and goes on to implement industrial strength generic components for real-world applications. Recurring issues that C++ developers face in their day-to-day activity are discussed in depth and implemented in a generic way. These include: Policy-based design for flexibility Partial template specialization Typelists\"{\i} powerful type manipulation structures Patterns such as Visitor, Singleton, Command, and Factories Multi-method enginesFor each generic component, the book presents the fundamental problems and design options, and finally implements a generic solution.In addition, an accompanying Web site, http://www.awl.com/cseng/titles/0-201-70431-5, makes the code implementations available for the generic components in the book and provides a free, downloadable C++ library, called Loki, created by the author. Loki provides out-of-the-box functionality for virtually any C++ project.Get a value-added service! Try out all the examples from this book at www.codesaw.com. CodeSaw is a free online learning tool that allows you to experiment with live code from your book right in your browser. 0201704315B11102003}
}

@book{testing_2008,
author = {Naik, Kshirasagar and Tripathy, Priyadarshi},
title = {Software Testing and Quality Assurance: Theory and Practice},
year = {2018},
isbn = {111919475X},
publisher = {Wiley Publishing},
edition = {2nd},
abstract = {This book introduces the fundamental ideas in testing theory, testing techniques, testing practices and quality assurance. Software Testing and Quality Assurance: Theory and Practicecovers the practices that support the production of quality software, software testing techniques, life-cycle models for requirements, defects, test cases, test results, test questions, examples, teaching suggestions, and chapter summaries. Other topics covered are; software quality assurance (SQA), SQA processes and metrics; the role of testing; basics of program testing; theory of program testing; code review; unit testing; test generation from control flow graphs, data flow graphs, and program domains; system integration; system testing; test execution; test automation; acceptance testing; quality metrics and reliability models. For the 2nd edition, the authors have included two major topics: (i) Boolean expression testing; and (ii) testing without oracles.}
}

@book{test_driven_2013,
author = {Langr, Jeff},
title = {Modern C++ Programming with Test-Driven Development: Code Better, Sleep Better},
year = {2013},
isbn = {1937785483},
publisher = {Pragmatic Bookshelf},
abstract = {If you program in C++ you've been neglected. Test-driven development (TDD) is a modern software development practice that can dramatically reduce the number of defects in systems, produce more maintainable code, and give you the confidence to change your software to meet changing needs. But C++ programmers have been ignored by those promoting TDD--until now. In this book, Jeff Langr gives you hands-on lessons in the challenges and rewards of doing TDD in C++.Modern C++ Programming With Test-Driven Development, the only comprehensive treatment on TDD in C++ provides you with everything you need to know about TDD, and the challenges and benefits of implementing it in your C++ systems. Its many detailed code examples take you step-by-step from TDD basics to advanced concepts. As a veteran C++ programmer, you're already writing high-quality code, and you work hard to maintain code quality. It doesn't have to be that hard. In this book, you'll learn: how to use TDD to improve legacy C++ systems how to identify and deal with troublesome system dependencies how to do dependency injection, which is particularly tricky in C++ how to use testing tools for C++ that aid TDD new C++11 features that facilitate TDD As you grow in TDD mastery, you'll discover how to keep a massive C++ system from becoming a design mess over time, as well as particular C++ trouble spots to avoid. You'll find out how to prevent your tests from being a maintenance burden and how to think in TDD without giving up your hard-won C++ skills. Finally, you'll see how to grow and sustain TDD in your team. Whether you're a complete unit-testing novice or an experienced tester, this book will lead you to mastery of test-driven development in C++.What You Need A C++ compiler running under Windows or Linux, preferably one that supports C++11. Examples presented in the book were built under gcc 4.7.2. Google Mock 1.6 (downloadable for free; it contains Google Test as well) or an alternate C++ unit testing tool. Most examples in the book are written for Google Mock, but it isn't difficult to translate them to your tool of choice. A good programmer's editor or IDE. cmake, preferably. Of course, you can use your own preferred make too. CMakeLists.txt files are provided for each project. Examples provided were built using cmake version 2.8.9. Various freely-available third-party libraries are used as the basis for examples in the book. These include: - cURL - JsonCpp - Boost (filesystem, date_time/gregorian, algorithm, assign) Several examples use the boost headers/libraries. Only one example uses cURL and JsonCpp.}
}

@misc{hoffman_martin,
title={CMake},
url={https://www.aosabook.org/en/cmake.html},
journal={The Architecture of Open Source Applications: CMake},
author={Hoffman, Bill and Martin, Kenneth},
urldate = {2020-04-10},
year = {2020}
}

@misc{pitsianis_2008,
title={CMake},
url={https://courses.cs.duke.edu//fall08/cps196.1/Pthreads/bitonic.c},
journal={Implementations of the bitonic sort:
recursive version and
imperative version},
author={Nikos Pitsianis},
urldate = {2020-08-06},
year = {2008}
}

@misc{jorge_2019,
title={An overview of build systems (mostly for C++ projects)},
url={https://medium.com/@julienjorge/an-overview-of-build-systems-mostly-for-c-projects-ac9931494444},
journal={Medium},
publisher={Medium},
author={Jorge, Julien},
year={2019},
month={Nov}
}

@inproceedings{stepanov_1998,
author = {Dehnert, James and Stepanov, Alexander},
year = {1998},
month = {01},
pages = {1-11},
title = {Fundamentals of Generic Programming},
volume = {1766},
journal = {LNCS},
doi = {10.1007/3-540-39953-4_1}
}

@misc{google_test_primer,
title={google/googletest},
url={https://github.com/google/googletest/blob/master/googletest/docs/primer.md},
journal={GitHub},
author={Google},
year={2020},
month={Aug},
urldate={2020-04-10}
}

@misc{google_benchmark,
title={google/benchmark},
url={https://github.com/google/benchmark},
journal={GitHub},
author={Google},
year={2020},
month={Aug},
urldate={2020-04-10}
}

@misc{constexpr_2017,
title={C++17 constexpr everything (or as much as the compiler can)},
url={https://solarianprogrammer.com/2017/12/27/cpp-17-constexpr-everything-as-much-as-the-compiler-can/},
journal={Solarian Programmer},
author={Paul Silisteanu},
year={2017},
month={Aug},
urldate={2020-04-10}
}

@misc{turner_2017,
title={constexpr ALL the Things!},
url={https://www.youtube.com/watch?v=PJwd4JLYJJY&t=797s},
journal={Solarian Programmer},
author={Ben Deane and Jason Turner},
year={2017},
month={Aug},
urldate={2020-04-10}
}
@article{van_roy_2012,
author = {Van Roy, Peter},
year = {2012},
month = {04},
pages = {},
title = {Programming Paradigms for Dummies: What Every Programmer Should Know}
}

@book{van_roy_2004,
author = {Van Roy, Peter and Haridi, Seif},
title = {Concepts, Techniques, and Models of Computer Programming},
year = {2004},
isbn = {0262220695},
publisher = {The MIT Press},
edition = {1st},
abstract = {This innovative text presents computer programming as a unified discipline in a way that is both practical and scientifically sound. The book focuses on techniques of lasting value and explains them precisely in terms of a simple abstract machine. The book presents all major programming paradigms in a uniform framework that shows their deep relationships and how and where to use them together. After an introduction to programming concepts, the book presents both well-known and lesser-known computation models ("programming paradigms"). Each model has its own set of techniques and each is included on the basis of its usefulness in practice. The general models include declarative programming, declarative concurrency, message-passing concurrency, explicit state, object-oriented programming, shared-state concurrency, and relational programming. Specialized models include graphical user interface programming, distributed programming, and constraint programming. Each model is based on its kernel language -- a simple core language that consists of a small number of programmer-significant elements. The kernel languages are introduced progressively, adding concepts one by one, thus showing the deep relationships between different models. The kernel languages are defined precisely in terms of a simple abstract machine. Because a wide variety of languages and programming paradigms can be modeled by a small set of closely related kernel languages, this approach allows programmer and student to grasp the underlying unity of programming. The book has many program fragments and exercises, all of which can be run on the Mozart Programming System, an Open Source software package that features an interactive incremental development environment.}
}

@book{stepanov_2015,
title={From mathematics to generic programming},
publisher={Addison-Wesley},
author={Stepanov, Alexander A. and Rose, Daniel E.},
year={2015}
}

@book{brookshear_2006,
title={Coputer Science: An Overview},
edition={9},
publisher={Addison-Wesley},
author={Brookshear, J. G.},
year={2006}
}

@book{watt_2004,
title={Programming Language Design Concepts},
publisher={J. Willey \& Sons,},
author={Watt, D.},
year={2004}
}

@book{scott_2000,
title={Programming Language Pragmatics},
location={San Francisco, CA, USA},
publisher={Morgan Kaufmann Publishers Inc},
author={Scott, M. L},
year={2000}
}

@book{gabbrielli_2010,
title={Programming Languages: principles and Paradigms. Series: Undergraduate Topics in Computer Science},
edition        = {1},
pages          = {440},
publisher={Springer London},
author={Maurizio Gabbrielli and Simone Martini},
year={2010},
doi            = {10.1007/978-1-84882-914-5},
isbn           = {978-1-84882-913-8},
location       = {New york},
}

@book{poo_2007,
author = {Poo, Danny and Kiong, Derek and Ashok, Swarnalatha},
title = {Object-Oriented Programming and Java},
year = {2007},
isbn = {1846289629},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg}
}

@book{pressman_2016,
  title={Engenharia de Software - 8{\textordfeminine} Edi{\c{c}}{\~a}o},
  author={Pressman, R. and Maxim, B.},
  isbn={9788580555349},
  url={https://books.google.com.br/books?id=wexzCwAAQBAJ},
  year={2016},
  publisher={McGraw Hill Brasil}
}

@article{henk_1984,
author = {Barendregt, Henk (Hendrik) and Barendsen, E.},
year = {1984},
month = {01},
pages = {337-372},
title = {Introduction to lambda calculus},
volume = {4},
journal = {Nieuw archief voor wisenkunde}
}

@inproceedings{jennings_1999,
author = {Jennings, Nicholas R.},
title = {Agent-Oriented Software Engineering},
year = {1999},
isbn = {3540662812},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
booktitle = {Proceedings of the 9th European Workshop on Modelling Autonomous Agents in a Multi-Agent World: MultiAgent System Engineering},
pages = {1–7},
numpages = {7},
series = {MAAMAW '99}
}

@book{laddad_2003,
author = {Laddad, Ramnivas},
title = {AspectJ in Action: Practical Aspect-Oriented Programming},
year = {2003},
isbn = {1930110936},
publisher = {Manning Publications Co.},
address = {USA}
}

@book{miles_2004,
author = {Miles, Russell},
title = {AspectJ Cookbook},
year = {2004},
isbn = {0596006543},
publisher = {O'Reilly Media, Inc.},
abstract = {This hands-on book shows readers why and how common Java development problems can be solved by using new Aspect-oriented programming (AOP) techniques. With a wide variety of code recipes for solving day-to-day design and coding problems using AOP's unique approach, AspectJ Cookbook demonstrates that AOP is more than just a concept; it's a development process that will benefit users in an immediate and visible manner.}
}

@book{dsouza_1998,
author = {D'Souza, Desmond F. and Wills, Alan Cameron},
title = {Objects, Components, and Frameworks with UML: The Catalysis Approach},
year = {1998},
isbn = {0201310120},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA}
}

@article{crnkovic_2002,
author = {Crnkovic, Ivica and Larsson, Magnus},
year = {2002},
month = {04},
pages = {201-212},
title = {Challenges of component-based development},
volume = {61},
journal = {Journal of Systems and Software},
doi = {10.1016/S0164-1212(01)00148-0}
}

 @misc{gwosdz_2020,
 title={If everyone hates it, why is OOP still so widely spread?},
 url={https://stackoverflow.blog/2020/09/02/if-everyone-hates-it-why-is-oop-still-so-widely-spread/},
 journal={Stack Overflow Blog},
 author={Madelen Gwosdz, Medi},
 year={2020},
 month={Sep}
 } 

@misc{tiobe_2020,
title={TIOBE Index for October 2020},
url={https://www.tiobe.com/tiobe-index/},
journal={TIOBE Software - The Coding Standards Company},
author={TIOBE},
year={2020},
month={Sep},
urldate      = {10-24-2020},
} 

@misc{tiobe_2021,
title={TIOBE Index for June 2021},
url={https://www.tiobe.com/tiobe-index/},
journal={TIOBE Software - The Coding Standards Company},
author={TIOBE},
year={2021},
month={Jun},
urldate      = {10-06-2020},
} 

@misc{pat_simao_2008,
  author       = {Sim{\~a}o, Jean Marcelo and Stadzisz, Paulo C{\'e}zar},
  title        = {Paradigma Orientado a Notificações (PON) – Uma
Técnica de Composição e Execução de Software Orientado a Notificações},
  howpublished = {Pedido de
Patente submetida ao INPI/Brazil (Instituto Nacional de Propriedade Industrial) em 2008 e
a Agência de Inovação/UTFPR em 2007. No. INPI Provisório 015080004262.Patente
submetida ao INPI},
  location     = {Brasil},
  year         = {2008}
}

@article{simao_tacla_2009,
author = {Sim{\~a}o, Jean Marcelo and Tacla, Cesar Augusto and Stadzisz, Paulo C{\'e}zar},
title = {Holonic Control Metamodel},
year = {2009},
issue_date = {September 2009},
publisher = {IEEE Press},
volume = {39},
number = {5},
issn = {1083-4427},
url = {https://doi.org/10.1109/TSMCA.2009.2022060},
doi = {10.1109/TSMCA.2009.2022060},
abstract = {Current production leanings, such as high product variability, demand advanced manufacturing systems (MSs). An example is the holonic MS (HMS) in which entities (e.g., resources and products) are "smart." These entities are called holons (HLs), and their interactions are coordinated by holonic control (HC). Indeed, the complexity of HMS has required new design and test tools. In this context, this paper presents an HC metamodel, which was applied to a particular simulator. In this control solution, causal knowledge is enclosed in Rule HLs, which receive facts about Resource HLs and deliberate about the actions to be executed. The inference happens by means of an innovative net of notifications built from expert knowledge, in the form of (Sub)-HLs, which allows high reactivity, HL decoupling, conflict handling, coherent control expression and execution, and easy control adaptations. This solution still considers other issues, namely, the product-driven manufacturing: a tendency related to customized production in which Product HLs negotiate with Resource HLs aiming at adaptability and reactivity. In this case, Rule HLs intermediate and organize the collaborations of Product HLs and Resource HLs. This paper proposes to use the metamodel to compose a process-driven control and a product-driven control applied to a similar simulated HMS, highlighting their differences and advantages.},
journal = {Trans. Sys. Man Cyber. Part A},
month = sep,
pages = {1126–1139},
numpages = {14},
keywords = {rule-based control, holonic manufacturing system (HMS), inference by notification, Control metamodel, simulation tool, product-driven control, control metamodel}
}

@article{simao_2009,
author = {Sim{\~a}o, Jean Marcelo and Tacla, Cesar Augusto and Stadzisz, Paulo C{\'e}zar},
title = {Inference Process Based on Notifications: The Kernel of
a Holonic Inference Meta-Model Applied to Control Issues},
year = {2009},
publisher = {IEEE Press},
volume = {39},
number = {1},
doi = {10.1109/TSMCA.2008.20066371},
journal = {IEEE Transactions on
Systems, Man and Cybernetics. Part A, Systems and Humans},
pages = {238-250},
}

@incollection{simao_livro_2002,
  author         = {Sim{\~a}o, Jean Marcelo and Stadzisz, Paulo C{\'e}zar},
  title          = {An Agent-Oriented Inference Engine applied for
Supervisory Control of Automated Manufacturing Systems},
  editor         = {J. Abe and J. Silva Filho},
  booktitle      = {Advances in Logic, Artificial Intelligence and Robotics},
  publisher      = {IOS Press Books},
  location       = {Netherlands},
  volume         = {85},
  pages          = {234-241},
  year           = {2002}
}

@article{simao_2012a,
author = {Sim{\~a}o, Jean Marcelo and Banaszewski, Roni F{\'a}bio and Tacla, Cesar Augusto and Stadzisz, Paulo C{\'e}zar},
title = {Notification Oriented Paradigm (NOP) and Imperative Paradigm: A Comparative Study},
year = {2012},
publisher = {IEEE Press},
volume = {39},
number = {1},
doi = {10.1109/TSMCA.2008.20066371},
journal = {IEEE Transactions on
Systems, Man and Cybernetics. Part A, Systems and Humans},
pages = {238-250},
}

@article{cardelli_1985,
author = {Cardelli, Luca and Wegner, Peter},
title = {On Understanding Types, Data Abstraction, and Polymorphism},
year = {1985},
issue_date = {Dec. 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {17},
number = {4},
issn = {0360-0300},
url = {https://doi.org/10.1145/6041.6042},
doi = {10.1145/6041.6042},
abstract = {Our objective is to understand the notion of type in programming languages, present a model of typed, polymorphic programming languages that reflects recent research in type theory, and examine the relevance of recent research to the design of practical programming languages.Object-oriented languages provide both a framework and a motivation for exploring the interaction among the concepts of type, data abstraction, and polymorphism, since they extend the notion of type to data abstraction and since type inheritance is an important form of polymorphism. We develop a λ-calculus-based model for type systems that allows us to explore these interactions in a simple setting, unencumbered by complexities of production programming languages.The evolution of languages from untyped universes to monomorphic and then polymorphic type systems is reviewed. Mechanisms for polymorphism such as overloading, coercion, subtyping, and parameterization are examined. A unifying framework for polymorphic type systems is developed in terms of the typed λ-calculus augmented to include binding of types by quantification as well as binding of values by abstraction.The typed λ-calculus is augmented by universal quantification to model generic functions with type parameters, existential quantification and packaging (information hiding) to model abstract data types, and bounded quantification to model subtypes and type inheritance. In this way we obtain a simple and precise characterization of a powerful type system that includes abstract data types, parametric polymorphism, and multiple inheritance in a single consistent framework. The mechanisms for type checking for the augmented λ-calculus are discussed.The augmented typed λ-calculus is used as a programming language for a variety of illustrative examples. We christen this language Fun because fun instead of λ is the functional abstraction keyword and because it is pleasant to deal with.Fun is mathematically simple and can serve as a basis for the design and implementation of real programming languages with type facilities that are more powerful and expressive than those of existing programming languages. In particular, it provides a basis for the design of strongly typed object-oriented languages.},
journal = {ACM Comput. Surv.},
month = dec,
pages = {471–523},
numpages = {53}
}

 @misc{grimm_2020,
 title={Modernes C++},
 url={https://www.modernescpp.com/index.php/more-powerful-lambdas-with-c-20},
 journal={ModernesCpp.com},
 author={Grimm, Rainer},
 year={2020}
 } 

 @misc{grimm_2017,
 title={Concurrency with Modern C++},
 url={https://www.modernescpp.com/images/stories/pdfs/ConcurrencyWithModernC++.pdf},
 journal={ModernesCpp.com},
 author={Grimm, Rainer},
 year={2017}
 } 

@misc{c_stories_2018,
title={The Amazing Performance of C 17 Parallel Algorithms, is it Possible?},
url={https://www.cppstories.com/2018/11/parallel-alg-perf/},
journal={C Stories},
year={2018},
month={Nov},
author={Bartlomiej Filipek}
}

@misc{jeong2012performance,
title={Performance of SSE and AVX Instruction Sets}, 
author={Hwancheol Jeong and Sunghoon Kim and Weonjong Lee and Seok-Ho Myung},
year={2012},
eprint={1211.0820},
archivePrefix={arXiv},
primaryClass={hep-lat}
}

@misc{boccara_2019,
title={Beyond Locks, a Safer and More Expressive Way to Deal with Mutexes in C },
url={https://www.fluentcpp.com/2019/04/26/how-to-write-safe-and-expressive-multi-threaded-code-in-cpp11/},
journal={Fluent C },
author={Boccara, Jonathan},
year={2019},
month={Jul}
}

@inproceedings{inproceedings,
author = {Ronszcka, Adriano and Ferreira, Cleverson and Stadzisz, Paulo and Fabro, João and Simão, Jean},
year = {2017},
month = {11},
pages = {125-131},
title = {Notification-Oriented Programming Language and Compiler},
doi = {10.1109/SBESC.2017.23},
journal={SBESC – VII Brazilian Symposium on Computing Systems Engineering},
}

 @article{Avacheva_2020,
author = {Avacheva, T and Prutzkow, Alexander},
year = {2020},
month = {01},
pages = {012001},
title = {The Evolution of Imperative Programming Paradigms as a Search for New Ways to Reduce Code Duplication},
volume = {714},
journal = {IOP Conference Series: Materials Science and Engineering},
doi = {10.1088/1757-899X/714/1/012001}
}


@misc{ferg_2006,
author = {FERG, S.},
year = {2006},
title = {Event-Driven Programming: Introduction, Tutorial, History.},
urldate = {12-17-2008}
}


@book{faison_2006,
author = {FAISON, T.},
year = {2006},
title = {Event-Based Programming: Taking Events to the Limit},
publisher = {Apress}
}

@book{gamma_1995,
author = {GAMMA, E. and HELM, R. and JOHNSON, R and VLISSIDES, J.},
year = {1995},
title = {Design Patterns: Elements of
Reusable Object-Oriented Software},
publisher = {Addison Wesley,}
}

@misc{bartlett_2005,
title={Introduction to metaprogramming},
url={https://www.ibm.com/developerworks/library/l-metaprog1/},
journal={The art of metaprogramming, Part 1},
publisher={IBM},
author={Bartlett, Jonathan},
year={2005},
month={Oct}
} 

@misc{bhadwal_2020,
title={Functional Programming: Concepts, Advantages, Disadvantages, and Applications},
url={https://hackr.io/blog/functional-programming},
publisher={hacker.io},
author={Bhadwal, Akhil},
year={2020},
month={Aug}
} 

@misc{henzen_2015,
title={Portabilidade do Framework PON de C++ standard para C\# e Java.},
author={Henzen, A. F.},
publisher={UTFPR},
address = {PPGCA},
location     = {Curitiba - PR, Brasil},
year={2015},
} 

@misc{belmonte_2012,
title={Método para Distribuição da Carga de Trabalho dos Softwares
PON em Multicore.},
author={Belmonte, Danilo},
publisher={Trabalho de Qualificação de Doutorado, CPGEI,
UTFPR},
location     = {Curitiba - PR, Brasil},
year={2012},
} 


@misc{neves_quali,
title={CONTRIBUIÇÃO PARA A CONCEPÇÃO DE APLICAÇÕES NO
PARADIGMA ORIENTADO A NOTIFICAÇÕES POR MEIO DE
PROGRAMAÇÃO GENÉRICA},
author={Felipe dos Santos Neves},
publisher={Trabalho de Qualificação de Mestrado, PPGCA,
UTFPR},
location     = {Curitiba - PR, Brasil},
year={2020},
} 


@misc{qt,
author = {Company Qt},
url={https://doc.qt.io/},
journal={Qt Documentation},
urldate={11-01-2020},
year = {2020}
}

@article{Ricci_2012,
author = {Ricci, Alessandro and Santi, Andrea},
year = {2012},
month = {01},
pages = {36-52},
title = {A Programming Paradigm based on Agent-Oriented Abstractions},
volume = {5},
journal = {International Journal of Advances in Software}
}

@techreport{iso_cpp17,
  added-at = {2018-02-01T12:31:24.000+0100},
  author = {{ISO/IEC}},
  biburl = {https://www.bibsonomy.org/bibtex/27e36ce1307fbcb3fe8ac2b6c9ff2fea0/gron},
  interhash = {c7296cbed20a319bf09091c6185c85c0},
  intrahash = {7e36ce1307fbcb3fe8ac2b6c9ff2fea0},
  keywords = {C++ Standard},
  month = {March},
  number = {N4660},
  timestamp = {2018-02-01T12:31:24.000+0100},
  title = {Programming Languages --- C++},
  type = {Draft International Standard},
  url = {https://web.archive.org/web/20170325025026/http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4660.pdf},
  year = 2017
}

@ARTICLE{ronszcka_2017,
author={A. F. Ronszcka and G. Z. Valenca and R. R. Linhares and J. A. Fabro and P. C. Stadzisz and J. M. Simao},
journal={IEEE Latin America Transactions},
title={Notification-Oriented Paradigm Framework 2.0: An Implementation Based On
Design Patterns},
year={2017},
volume={15},
number={11},
pages={2220-2231},
doi={10.1109/TLA.2017.8070430}
}

@ARTICLE{belmonte_2016,
author={D. L. Belmonte and R. R. Linhares and P. C. Stadzisz and J. M. Simao},
journal={IEEE Latin America Transactions},
title={A new Method for Dynamic Balancing of Workload and Scalability in Multicore Systems},
year={2016},
volume={14},
number={7},
pages={3335-3344},
doi={10.1109/TLA.2016.7587639}
}

@misc{renaux_2015,
author={RENAUX, Douglas P. B. and Linhares, Robson Ribeiro and Simao, Jean Marcelo and Stadzisz, Paulo Cézar},
title={CTA SImulator - Concepts of Operations},
year={2015},
url={http://www.dainf.ct.utfpr.edu.br/~douglas/CTA_CONOPS.pdf},
urldate={11-01-2019}
}

@misc{martini_2019,
  title={NOP on multi-core architecture computers},
  author={Guilherme H. K. Martini and J. Sim{\~a}o and R. Linhares},
  year={2019},
  publisher       = {UTFPR},
  address = {PPGCA},
  howpublished = {Trabalho realizado na disciplina Tópicos Avançados Em Sistemas Embarcado
(CAES102 – UTFPR)},
}

@misc{pat_simao_2017,
  author       = {Sim{\~a}o, Jean Marcelo and Ronszcka, A. F. and Valença, G. Z. and Linhares, R. R. and Stadziz, P. C.},
  title        = {Framework PON C++ 2.0},
  howpublished = {Patente de Programa de Computador no INPI, Número
do registro: BR51201700149-5, data de registro: 01/12/201},
  location     = {Brasil},
  year         = {2017}
}


@book{nambiar_2009,
  author       = {Nambiar and  Raghunath and Poess and Meikel},
  title        = {Performance Evaluation and Benchmarking},
  publisher      = {Springer},
  year         = {2009},
  isbn           = {978-3-642-10423-7},
}

@article{schutz_2018,
author = {Sch{\"u}tz, Fernando and Fabro, João and Ronszcka, Adriano and Stadzisz, Paulo and Simão, Jean},
year = {2018},
month = {09},
pages = {},
title = {Proposal of a declarative and parallelizable artificial neural network using the notification-oriented paradigm},
volume = {30},
journal = {Neural Computing and Applications},
doi = {10.1007/s00521-018-3517-y}
}

@misc{athayde_2016,
  author       = {Athayde, E. B. and Negrini, F.},
  title        = {Implementação de Compilação para C++
Namespaces para a LingPON e Otimizações no Tratamento de Premissas},
  howpublished = {Trabalho realizado na disciplina Tópicos Avançados em Engenharia de Software
(CAES101)},
  year         = {2016},
  publisher = {PPGCA/UTFPR},
  location     = {Curitiba, Brasil}
}

@misc{schutz_2015,
  author       = {Sch{\"u}tz, Fernando and Ronszcka, Adriano},
  title        = {Compilação C++ Estático},
  howpublished = {Relatório para Disciplina Linguagens e Compiladores PON},
  publisher = {UTFPR},
  year         = {2015}
}

@misc{ambler_2006,
url={http://agiledata.org/essays/tdd.html},
journal={Introduction to Test Driven Development (TDD)},
author={Ambler, Scott W.},
year={2006}
} 

@misc{mody_2017,
title={Test Driven Development - Breaking Down Unit And Integration Tests},
url={https://medium.com/@RahulTMody/test-driven-development-breaking-down-unit-integration-tests-d4a723817419},
journal={Medium},
publisher={Medium},
author={Mody, Rahul},
year={2017},
month={Jul}
} 

@book{binder_1999,
author = {Binder, Robert V.},
title = {Testing Object-Oriented Systems: Models, Patterns, and Tools},
year = {1999},
isbn = {0201809389},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA}
}

@misc{flury_2018,
author = {Tony Flury},
publisher= {Quora},
year = {2018},
title = {What are the best programming paradigms?},
urldate = {05-26-2018}
}

@misc{neves_2020,
  author       = {Felipe dos Santos Neves},
  title        = {Comparisons on Game Development with Unreal
Engine 4 using Object Oriented Paradigm (OOP in
C++) versus Notification Oriented Paradigm},
  howpublished = {Relatório na forma de artigo para da disciplina de Paradigmas de Programação
(1o trimestre de 2020)},
  year         = {2020},
  address = {CPGEI},
  publisher = {UTFPR}
}

@misc{lima_2020,
  author       = {Anderson Eduardo de Lima and Felipe dos Santos Neves and Lucas Tachini Garcia and Luis Henrique Santana and Omero Francisco Bertol},
  title        = {AVANÇOS NA APLICAÇÃO DE FUTEBOL DE ROBÔS EM FRAMEWORK PON C++ 2.0 DO PARADIGMA ORIENTADO A NOTIFICAÇÕES – PON},
  howpublished = {Relatório em formato de artigo para a disciplina de Tópicos Especiais em EC: Paradigma Orientado a Notificações (segundo trimestre de 2020)},
  year         = {2020},
  publisher = {UTFPR},
  address = {CPGEI}
}

@inproceedings{cardoso_2013,
author = {Cardoso, Rafael and H{\"u}bner, Jomi and Bordini, Rafael},
year = {2013},
month = {05},
pages = {1267-1268},
title = {Benchmarking Communication in Actor- and Agent-Based Languages},
doi = {10.1007/978-3-642-45343-4_4}
}

@misc{pordeus_2020,
  author       = {L. F. Pordeus and A. E. Lazzaretti and R. R. Linhares and J. M. Simão},
  title        = {NOP-DH - Evaluation Over Random Forest Algorithm},
  year         = {2020},
  publisher = {UTFPR}
}

@article{pordeus_2021,
title = {NOP-DH – Evaluation Over Bitonic Sort Algorithm},
journal = {Microprocessors and Microsystems},
pages = {104314},
year = {2021},
issn = {0141-9331},
doi = {https://doi.org/10.1016/j.micpro.2021.104314},
url = {https://www.sciencedirect.com/science/article/pii/S0141933121004750},
author = {L.F. Pordeus and R.R. Linhares and P.C. Stadzisz and J.M. Simão},
keywords = {Notification Oriented Paradigms, Digital Hardware Design, FPGA, Bitonic Sort},
abstract = {The growing use of Field Programmable Gate Array (FPGA) to increase application performance requires tools that simplify the digital circuit development process. Traditional approaches of Hardware Description Languages (HDLs) are complex and require specialized knowledge at a low-level abstraction. In turn, different approaches called High-Level Synthesis (HLS) aim at facilitating the development of FPGA applications, making this development process closer to those of software using programming languages such as C or C++. However, these alternatives do not properly exploit the parallelism capability of FPGAs as they are based on usual sequential approaches and, moreover, continue to depend on developer technical knowledge about the target hardware. The Notification Oriented Paradigm (NOP) emerges as an alternative to develop and execute applications. The NOP brings a new inference concept based on precise notifying collaborative entities. This type of inference allows presenting an innovative way of implicitly achieving decoupled and decentralized solutions, thereby enabling parallelism and distribution in a level of granularity as fine as possible in the envisaged computational platform. In this context, researches on NOP have proposed the design of digital circuits based on the NOP model, called NOP Digital Hardware (DH). In this paper, it is proposed to evaluate the use of the NOP-DH to develop the well-known Bitonic Sort, which is a sort algorithm useful as benchmark. This algorithm has particular properties that are advantageous for parallel execution, especially in FPGAs. Experiments were performed to compare the performance, amount of logic elements, and maximum frequency of NOP-DH against the traditional VHDL approach. These experiments demonstrated that even with a higher abstraction level of development, NOP-DH circuits achieve similar results when compared to the traditional development in VHDL.}
}

@article{criminisi_2011,
author = {Criminisi, Antonio and Shotton, Jamie and Konukoglu, Ender},
year = {2011},
month = {01},
pages = {81-227},
title = {Decision Forests: A Unified Framework for Classification, Regression, Density Estimation, Manifold Learning and Semi-Supervised Learning},
volume = {7},
journal = {Foundations and Trends in Computer Graphics and Vision},
doi = {10.1561/0600000035}
}

@misc{Mullapudi_2014,
  Author = {Amrutha Mullapudi},
  publisher = {University at Buffalo},
  Howpublished = {Lecture for CSE633: Parallel Algorithms (Spring 2014)},
  Year = {2014},
  Title = {Bitonic Sort}
}

@misc{lasn_2019,
  Author = {Indrek Lasn},
  publisher = {Medium},
  url = {https://medium.com/better-programming/what-is-component-oriented-programming-cop-10b32ae1fa1c},
  Year = {2019},
  Title = {What is Component-Oriented Programming (COP)?}
}

@misc{feldman_2019,
title = {Why Isn't Functional Programming the Norm?},
year = {2019},
publisher = {Metosin},
author = {Richard Feldman},
url = {https://www.youtube.com/watch?v=QyJZzq0v7Z4&t=776s},
}

@inproceedings{batcher_68,
author = {Batcher, Kenneth},
year = {1968},
month = {01},
pages = {307-314},
title = {Sorting networks and their applications},
volume = {32},
journal = {Proceed. AFIPS Spring Joint Comput. Conf.},
doi = {10.1145/1468075.1468121}
}

@misc{oneal_2018,
title = {Using C++17 Parallel Algorithms for Better Performance},
year = {2018},
publisher = {Microsoft},
author = {Billy O'Neal},
url = {https://devblogs.microsoft.com/cppblog/using-c17-parallel-algorithms-for-better-performance/},
}


@misc{teixeira_2012,
title = {Inside Windows 8: Pedro Teixeira - Thread pools},
year = {2012},
publisher = {Channel 9},
author = {Pedro Teixeira},
url = {https://channel9.msdn.com/Shows/Going+Deep/Inside-Windows-8-Pedro-Teixeira-Thread-pool},
}

@misc{skora_2020,
  author       = {Lucas Eduardo Bonancio Skora},
  title        = {Cria{\c{c}}{\~a}o de alvos de compila{\c{c}}{\~a}o para a NOPL e
  ferramentas de serializa{\c{c}}{\~a}o-desserializa{\c{c}}{\~a}o para o
  Grafo PON},
  howpublished = {Trabalho realizado na disciplina Paradigmas de Programação},
  year         = {2020},
  publisher = {CPGEI/UTFPR},
  location     = {Curitiba, Brasil}
}

@misc{skora_2021,
author       = {Lucas Eduardo Bonancio Skora},
title        = {ANALISADORES LÉXICO-SINTÁTICOS EM PON E POO},
howpublished = {Relatório em formato de artigo para a disciplina de Estudo Especial em Paradigmas de Programação CSE20 no CPGEI - UTFPR},
year         = {2021},
publisher = {UTFPR}
}

@book{cpp_primer,
author = {Lippman, Stanley B. and Lajoie, Jos\'{e}e and Moo, Barbara E.},
title = {C++ Primer (5th Edition)},
year = {2013},
isbn = {0-321-71411-3},
publisher = {Addison-Wesley Professional},
abstract = {This popular tutorial introduction to standard C++ has been completely updated, reorganized, and rewritten to help programmers learn the language faster and use it in a more modern, effective way.Just as C++ has evolved since the last edition, so has the authors' approach to teaching it. They now introduce the C++ standard library from the beginning, giving readers the means to write useful programs without first having to master every language detail. Highlighting today's best practices, they show how to write programs that are safe, can be built quickly, and yet offer outstanding performance. Examples that take advantage of the library, and explain the features of C++, also show how to make the best use of the language. As in its previous editions, the book's authoritative discussion of fundamental C++ concepts and techniques makes it a valuable resource even for more experienced programmers.Program Faster and More Effectively with This Rewritten Classic Restructured for quicker learning, using the C++ standard library Updated to teach the most current programming styles and program design techniques Filled with new learning aids that emphasize important points, warn about common pitfalls, suggest good programming practices, and provide general usage tips Complete with exercises that reinforce skills learned Authoritative and comprehensive in its coverageThe source code for the book's extended examples is available on the Web at the address below.}
}

@book{modern_cpp,
author = {Scott Meyers},
title = {Effective Modern C++},
year = {2015},
isbn = {978-1-491-90399-5},
publisher = {O’Reilly},
}


@book{turner_2020,
author = {Jason Turner},
title = {C++ Best Practices},
year = {2021},
publisher = {Leanpub},
}

@misc{talau_2016,
  author       = {Marcos Talau},
  title        = {PONIP: Uso do Paradigma Orientado a Notifica{\c{c}}{\~o}es em Redes IP},
  howpublished = {Trabalho realizado na disciplina Paradigmas Orientado a Notificações},
  year         = {2016},
  publisher = {CPGEI/UTFPR},
  location     = {Curitiba, Brasil}
}

@inproceedings{neves_icist_2021,
 author = {Neves, Felipe dos Santos and Sim{\~a}o, Jean Marcelo and Linhares, Robson Ribeiro},
 title = {Application of generic programming for the
 development of a C++ framework for the
 Notification Oriented Paradigm},
 pages           = {56-61},
 booktitle = {ICIST 2021 Proceedings},
 year = {2021},
 pages           = {56-61},
 editor          = {Zdravković, M. and Trajanović, M. and Konjović, Z.},
 location        = {Servia}
 }

@inproceedings{martini_2021,
 author = {Guilherme Henrique Kaehler Martin and Adriano Francisco Ronszcka and Jo{\~a}o Alberto Fabro and Jean Marcelo Sim{\~a}o},
 title = {Multi-threading capability evaluation of the Notification Oriented Programming Language for the x86 Architecture},
 pages           = {44-49},
 booktitle = {ICIST},
 location = {Servia},
 year = {2021}
}

@article{forgy_1982,
title = {Rete: A fast algorithm for the many pattern/many object pattern match problem},
journal = {Artificial Intelligence},
volume = {19},
number = {1},
pages = {17-37},
year = {1982},
issn = {0004-3702},
doi = {https://doi.org/10.1016/0004-3702(82)90020-0},
url = {https://www.sciencedirect.com/science/article/pii/0004370282900200},
author = {Charles L. Forgy},
abstract = {The Rete Match Algorithm is an efficient method for comparing a large collection of patterns to a large collection of objects. It finds all the objects that match each pattern. The algorithm was developed for use in production system interpreters, and it has been used for systems containing from a few hundred to more than a thousand patterns and objects. This article presents the algorithm in detail. It explains the basic concepts of the algorithm, it describes pattern and object representations that are appropriate for the algorithm, and it describes the operations performed by the pattern matcher.}
}

@inproceedings{miranker_1987,
author = {Miranker, Daniel P.},
title = {TREAT: A Better Match Algorithm for AI Production Systems},
year = {1987},
isbn = {0934613427},
publisher = {AAAI Press},
abstract = {This paper presents the TREAT match algorithm for AI production systems. The TREAT algorithm introduces a new method of state saving in production system interpreters called conflict-set support. Also presented are the results of an empirical study comparing the performance of the TREAT match with the commonly assumed best algorithm for this problem, the RETE match. On five different OPS5 production system programs TREAT outperformed RETE, often by more than fifty percent. This supports an unsubstantiated conjecture made by McDermott, Newell and Moore, that the state saving mechanism employed in the RETE match, condition-element support, may not be worthwhile.},
booktitle = {Proceedings of the Sixth National Conference on Artificial Intelligence - Volume 1},
pages = {42–47},
numpages = {6},
location = {Seattle, Washington},
series = {AAAI'87}
}

@inproceedings{miranker_1990,
author = {Daniel P. Miranker and David A. Brant},
title = {An Algorithmic Basis for Integrating Production Systems and Large Databases},
booktitle = {Proceedings of the Sixth International Conference on Data Engineering,
February 5-9, 1990, Los Angeles, California, USA},
publisher = {IEEE Computer Society},
year = {1990},
isbn = {0-8186-2025-0},
pages = {353-360},
}

@inproceedings{lee_2002,
author={Pou-Yung Lee and Cheng, A.M.K.},
journal={IEEE Transactions on Knowledge and Data Engineering},
title={HAL: a faster match algorithm},
year={2002},
volume={14},
number={5},
pages={1047-1058},
doi={10.1109/TKDE.2002.1033773}
}

@book{beck_2002,
author = {Kent Beck and Ward Kunningham},
title = {Test Driven Development: By Example},
year = {2002},
isbn = {0321146530},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA},
abstract = {From the Book: Clean code that works is Ron Jeffries' pithy phrase. The goal is clean code that works, and for a whole bunch of reasons: Clean code that works is a predictable way to develop. You know when you are finished, without having to worry about a long bug trail. Clean code that works gives you a chance to learn all the lessons that the code has to teach you. If you only ever slap together the first thing you think of, you never have time to think of a second, better, thing. Clean code that works improves the lives of users of our software. Clean code that works lets your teammates count on you, and you on them. Writing clean code that works feels good.But how do you get to clean code that works Many forces drive you away from clean code, and even code that works. Without taking too much counsel of our fears, here's what we dodrive development with automated tests, a style of development called Test-Driven Development (TDD for short). In Test-Driven Development, you: Write new code only if you first have a failing automated test. Eliminate duplication. Two simple rules, but they generate complex individual and group behavior. Some of the technical implications are: You must design organically, with running code providing feedback between decisions You must write your own tests, since you can't wait twenty times a day for someone else to write a test Your development environment must provide rapid response to small changes Your designs must consist of many highly cohesive, loosely coupled components, just to make testing easy The two rules imply an order to the tasks ofprogramming: 1. Redwrite a little test that doesn't work, perhaps doesn't even compile at first 2. Greenmake the test work quickly, committing whatever sins necessary in the process 3. Refactoreliminate all the duplication created in just getting the test to work Red/green/refactor. The TDD's mantra. Assuming for the moment that such a style is possible, it might be possible to dramatically reduce the defect density of code and make the subject of work crystal clear to all involved. If so, writing only code demanded by failing tests also has social implications: If the defect density can be reduced enough, QA can shift from reactive to pro-active work If the number of nasty surprises can be reduced enough, project managers can estimate accurately enough to involve real customers in daily development If the topics of technical conversations can be made clear enough, programmers can work in minute-by-minute collaboration instead of daily or weekly collaboration Again, if the defect density can be reduced enough, we can have shippable software with new functionality every day, leading to new business relationships with customers So, the concept is simple, but what's my motivation Why would a programmer take on the additional work of writing automated tests Why would a programmer work in tiny little steps when their mind is capable of great soaring swoops of design Courage.Courage Test-driven development is a way of managing fear during programming. I don't mean fear in a bad way, pow widdle prwogwammew needs a pacifiew, but fear in the legitimate, this-is-a-hard-problem-and-I-can't-see-the-end-from-the-beginning sense. If pain is nature's way of saying Stop!, fear is nature's way of saying Be careful. Being careful is good, but fear has a host of other effects: Makes you tentative Makes you want to communicate less Makes you shy from feedback Makes you grumpy None of these effects are helpful when programming, especially when programming something hard. So, how can you face a difficult situation and: Instead of being tentative, begin learning concretely as quickly as possible. Instead of clamming up, communicate more clearly. Instead of avoiding feedback, search out helpful, concrete feedback. (You'll have to work on grumpiness on your own.) Imagine programming as turning a crank to pull a bucket of water from a well. When the bucket is small, a free-spinning crank is fine. When the bucket is big and full of water, you're going to get tired before the bucket is all the way up. You need a ratchet mechanism to enable you to rest between bouts of cranking. The heavier the bucket, the closer the teeth need to be on the ratchet. The tests in test-driven development are the teeth of the ratchet. Once you get one test working, you know it is working, now and forever. You are one step closer to having everything working than you were when the test was broken. Now get the next one working, and the next, and the next. By analogy, the tougher the programming problem, the less ground should be covered by each test. Readers of Extreme Programming Explained will notice a difference in tone between XP and TDD. TDD isn't an absolute like Extreme Programming. XP says, Here are things you must be able to do to be prepared to evolve further. TDD is a little fuzzier. TDD is an awareness of the gap between decision and feedback during programming, and techniques to control that gap. What if I do a paper design for a week, then test-drive the code Is that TDD Sure, it's TDD. You were aware of the gap between decision and feedback and you controlled the gap deliberately. That said, most people who learn TDD find their programming practice changed for good. Test Infected is the phrase Erich Gamma coined to describe this shift. You might find yourself writing more tests earlier, and working in smaller steps than you ever dreamed would be sensible. On the other hand, some programmers learn TDD and go back to their earlier practices, reserving TDD for special occasions when ordinary programming isn't making progress. There are certainly programming tasks that can't be driven solely by tests (or at least, not yet). Security software and concurrency, for example, are two topics where TDD is not sufficient to mechanically demonstrate that the goals of the software have been met. Security relies on essentially defect-free code, true, but also on human judgement about the methods used to secure the software. Subtle concurrency problems can't be reliably duplicated by running the code. Once you are finished reading this book, you should be ready to: Start simply Write automated tests Refactor to add design decisions one at a time This book is organized into three sections. An example of writing typical model code using TDD. The example is one I got from Ward Cunningham years ago, and have used many times since, multi-currency arithmetic. In it you will learn to write tests before code and grow a design organically. An example of testing more complicated logic, including reflection and exceptions, by developing a framework for automated testing. This example also serves to introduce you to the xUnit architecture that is at the heart of many programmer-oriented testing tools. In the second example you will learn to work in even smaller steps than in the first example, including the kind of self-referential hooha beloved of computer scientists. Patterns for TDD. Included are patterns for the deciding what tests to write, how to write tests using xUnit, and a greatest hits selection of the design patterns and refactorings used in the examples. I wrote the examples imagining a pair programming session. If you like looking at the map before wandering around, you may want to go straight to the patterns in Section 3 and use the examples as illustrations. If you prefer just wandering around and then looking at the map to see where you've been, try reading the examples through and refering to the patterns when you want more detail about a technique, then using the patterns as a reference. Several reviewers have commented they got the most out of the examples when they started up a programming environment and entered the code and ran the tests as they read. A note about the examples. Both examples, multi-currency calculation and a testing framework, appear simple. There are (and I have seen) complicated, ugly, messy ways of solving the same problems. I could have chosen one of those complicated, ugly, messy solutions to give the book an air of reality. However, my goal, and I hope your goal, is to write clean code that works. Before teeing off on the examples as being too simple, spend 15 seconds imagining a programming world in which all code was this clear and direct, where there were no complicated solutions, only apparently complicated problems begging for careful thought. TDD is a practice that can help you lead yourself to exactly that careful thought.}
}

@misc{shah_2021,
title={Advantages and Disadvantages of Event-Driven Programming},
url={https://benchpartner.com/advantages-and-disadvantages-of-event-driven-programming},
journal={Bench Partner},
author={Shah, Rajiv},
year={2021},
month={Jun}
} 

@misc{hurd_2021,
title={Introduction to Data Types: Static, Dynamic, Strong and Weak},
url={https://www.sitepoint.com/typing-versus-dynamic-typing/},
journal={SitePoint},
publisher={SitePoint},
author={Hurd, Tim},
year={2021}, 
month={Jun}
}

@article{chien_2011,
author = {Borkar, Shekhar and Chien, Andrew A.},
title = {The Future of Microprocessors},
year = {2011},
issue_date = {May 2011},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {54},
number = {5},
issn = {0001-0782},
url = {https://doi.org/10.1145/1941487.1941507},
doi = {10.1145/1941487.1941507},
abstract = {Energy efficiency is the new fundamental limiter of processor performance, way beyond
numbers of processors.},
journal = {Commun. ACM},
month = may,
pages = {67–77},
numpages = {11}
}

@misc{thorsen_2015,
title={Using Templates to Avoid Code Duplication},
url={https://www.vikingsoftware.com/using-templates-to-avoid-code-duplication/},
journal={Viking Software A/S},
author={Thorsen, Bo},
year={2015},
month={Feb}}

@misc{bos_2019,
title={C++ Compile-Time Exceptions},
url={https://blog.esciencecenter.nl/c-compile-time-exceptions-5443f5bf06fe},
journal={Medium},
publisher={Netherlands eScience Center},
author={Bos, Patrick},
year={2019},
month={Jan}
}

@inproceedings{negrini_2019,
 author = {Fabio Negrini and Adriano Ronszcka and Robson Linhares and João Fabro and Paulo Stadzisz and Jean Marcelo Simão},
 title = {NOPL-Erlang: Programação multicore transparente em linguagem de alto nível},
 booktitle = {Anais da V Escola Regional de Alto Desempenho do Rio de Janeiro},
 location = {Rio de Janeiro},
 year = {2019},
 keywords = {},
 issn = {0000-0000},
 pages = {16--20},
 publisher = {SBC},
 address = {Porto Alegre, RS, Brasil},
 url = {https://sol.sbc.org.br/index.php/eradrj/article/view/9535}
}


@article{negrini_2019_2,
	title = {{NOPL}-{Erlang}: {Programação} multicore transparente em linguagem de alto nível},
	volume = {43},
	copyright = {Direitos autorais 2020 Cadernos do IME - Série Informática},
	issn = {2317-2193},
	shorttitle = {{NOPL}-{Erlang}},
	url = {https://www.e-publicacoes.uerj.br/index.php/cadinf/article/view/54404},
	doi = {10.12957/cadinf.2019.54404},
	abstract = {O aumento da capacidade computacional dos processadores tem sido alcançado por meio do incremento de núcleos dentro de um mesmo processador. Esta solução, entretanto, aumenta consideravelmente a complexidade de programação, obrigando desenvolvedores fazerem uso técnica de programação concorrente. Neste artigo é apresentado a NOPL, linguagem própria do PON com propriedades desacoplante e não sequencial. NOPL é uma linguagem que permite a programação concorrente de maneira transparente e em alto nível. O artigo apresenta a linguagem NOPL e sua integração com a arquitetura Erlang para explorar execução concorrente. Nos resultados é possível verificar a redução significativa no tempo de execução à medida em que se aumenta o número de núcleos disponíveis.},
	language = {pt},
	number = {2},
	urldate = {2021-09-08},
	journal = {Cadernos do IME - Série Informática},
	author = {Negrini, Fabio and Ronszcka, Adriano Francisco and Linhares, Robson Ribeiro and Fabro, João Alberto and Stadzisz, Paulo Cézar and Simão, Jean Marcelo},
	year = {2019},
	pages = {70--74},
}


@book{henessy_2003,
author = {Hennessy, John and Patterson, David},
year = {2003},
month = {01},
pages = {},
title = {Computer architecture - a quantitative approach, 3rd Edition.},
isbn = {978-1-55860-596-1}
}

@article{asanovic_2009,
author = {Asanovic, Krste and Bodik, Rastislav and Demmel, James and Keaveny, Tony and Keutzer, Kurt and Kubiatowicz, John and Morgan, Nelson and Patterson, David and Sen, Koushik and Wawrzynek, John and Wessel, David and Yelick, Katherine},
title = {A View of the Parallel Computing Landscape},
year = {2009},
publisher = {Association for Computing Machinery},
location = {New York, NY, USA},
volume = {52},
number = {10},
issn = {0001-0782},
url = {https://doi.org/10.1145/1562764.1562783},
doi = {10.1145/1562764.1562783},
journal = {Commun. ACM},
month = {oct},
pages = {56–67}
}

@inproceedings{oshiro_2021,
 author = {Larissa Oshiro and Adriano Ronszcka and João Fabro and Jean Simão},
 title = {Linguagem e Compilador para o Paradigma Orientado a Notificações: Uma Solução Performante Orientada a Regras},
 booktitle = {Anais da XII Escola Regional de Alto Desempenho de São Paulo},
 location = {Evento Online},
 year = {2021},
 keywords = {},
 issn = {0000-0000},
 pages = {61-64},
 publisher = {SBC},
 address = {Porto Alegre, RS, Brasil},
 doi = {10.5753/eradsp.2021.16706},
 url = {https://sol.sbc.org.br/index.php/eradsp/article/view/16706}
}

@book{scott_2009,
author = {Scott, Michael L.},
title = {Programming Language Pragmatics, Third Edition},
year = {2009},
isbn = {0123745144},
publisher = {Morgan Kaufmann Publishers Inc.},
address = {San Francisco, CA, USA},
edition = {3rd},
}

@inproceedings{doorenbos_1995,
  title={Production Matching for Large Learning Systems},
  author={Robert B. Doorenbos},
  year={1995}
}

@misc{muchalski_2012,
  author       = {Fernando José Muchalski and C. A. Maziero and P. C. Stadzisz and J. M. Simão},
  title        = {Estudo Comparativo entre o Paradigma de Programação Orientado a Objetos e o Paradigma Orientado a Notificações em um Sistema para Cálculo de Produtividade},
  howpublished = {Trabalho realizado na disciplina Tópicos Avançados Em Sistemas Embarcados (CASE102)},
  year         = {2012},
  publisher = {CPGEI/UTFPR},
  location     = {Curitiba, Brasil}
}

@misc{chierichi_2020,
  author       = {Gustavo Brunholi Chierici},
  title        = {JuNOC++ e NOPL Lite: uma nova forma de compor aplicções do Paradigma Orientado a  Notificações em alto nível por meio de um novo framework em C++ e um dialeto de NOPL},
  howpublished = {Trabalho realizado na disciplina Tópicos Especiais em EC: Paradigma Orientado A Notificações (TEC0301)},
  year         = {2020},
  publisher = {CPGEI/UTFPR},
  location     = {Curitiba, Brasil}
}

@article{kerschbaumer_2018_1,
author={Kerschbaumer, R. and Simão, J. M. and Fabro, J. A. and Erig Lima, C. R. and Linhares, R. R.},
journal={IEEE Latin America Transactions},
title={A Tool for Digital Circuits Synthesis Based on Notification Oriented Paradigm},
year={2018},
volume={16},
number={6},
pages={1574-1586},
doi={10.1109/TLA.2018.8444152}
}

@article{kerschbaumer_2018_2,
author = {Kerschbaumer, Ricardo and Linhares, Robson R. and Simão, Jean M. and Stadzisz, Paulo C. and Erig Lima, Carlos R.},
title = {Notification-Oriented Paradigm to Implement Digital Hardware},
journal = {Journal of Circuits, Systems and Computers},
volume = {27},
number = {08},
pages = {1850124},
year = {2018},
doi = {10.1142/S0218126618501244},
URL = {https://doi.org/10.1142/S0218126618501244},
eprint = {https://doi.org/10.1142/S0218126618501244},
abstract = { The growing demand for high-performance digital circuits, mainly involving FPGAs, increases the demand for high-level synthesis (HLS) tools. Traditional Hardware Description Languages (HDLs) are complex and depend on low-level abstractions, thereby requiring hardware detailed knowledge from developers. In turn, the current HLS tools are based on proprietary or C/C++ derived languages, which allow easier circuit description but decrease performance. This work presents an alternative solution for designing digital circuits, which arises from the Notification-Oriented Paradigm (NOP). The NOP is an alternative computing solution based upon a set of predefined interconnected entities whose collaborations are performed through precise notifications. The NOP, when targeted to digital hardware (DH), allows the developer to describe the circuit behavior just by connecting and parameterizing elements. The result is a VHDL file that can be compiled for any platform from any manufacturer. In order to check the functionality of this approach, sorting circuits were built both with usual VHDL and with the NOP VHDL aiming to compare the resulting circuits in terms of operating frequency and resource use. The results show that the NOP VHDL approach facilitates the build of digital circuits when compared to the VHDL usual approach without limiting the operating frequency or increasing the use of resources. }
}

@inproceedings{peters_2012,
author={Peters, Eduardo and Jasinski, Ricardo P. and Pedroni, Volnei A. and Simão, Jean M.},
booktitle={2012 International Conference on Field-Programmable Technology},
title={A new hardware coprocessor for accelerating Notification-Oriented applications},
year={2012},
volume={},
number={},
pages={257-260},
doi={10.1109/FPT.2012.6412145}
}

@ARTICLE{linhares_2020,
author={Linhares, Robson R. and Pordeus, Leonardo F. and Simão, Jean M. and Stadzisz, Paulo C.},
journal={IEEE Access},
title={NOCA — A Notification-Oriented Computer Architecture: Prototype and Simulator},
 year={2020},
 volume={8},
 number={},
 pages={37287-37304},
 doi={10.1109/ACCESS.2020.2975360}
 }

@article{barreto_2018,
  title={Notification Oriented Paradigm for Distributed Systems},
  author={Wagner R. M. Barretto and A. Vendramin and J. M. Sim{\~a}o},
  journal={Anais do Computer on the Beach},
  year={2018},
  pages={110-119}
}

@ARTICLE{oliveira_2018,
author={Nunes Oliveira, Rodrigo and Roth, Valmir and Felippeto Henzen, Alexandre and Simao, Jean Marcelo and Nohama, Percy and Gomes Wille, Emilio Carlos},  journal={IEEE Latin America Transactions},
title={Notification Oriented Paradigm Applied to Ambient Assisted Living Tool},
year={2018},
volume={16},
number={2},
pages={647-653},
doi={10.1109/TLA.2018.8327425}
}